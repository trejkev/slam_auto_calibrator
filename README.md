# SLAM Automated Calibrator using a Genetic Algorithm via DEAP

This ROS node can perform automated external calibration of a SLAM algorithm's map accuracy, being managed by a set of robots collaborating between them, or a single robot (it will depend on the .launch files setup), and using the humongous power that Genetic Algorithms provide. It makes use of DEAP library, with the eaSimple method, which implements a simple but powerful genetic algorithm.

An output example can be seen in the figure below, where we made a simulated arena with 3  TurtleBot3 robots (left side figure), started with default parameters to show their resulting map (central figure), and ended with a set of parameters that hugely optimized the resulting map (right side figure) in a relatively short number of optimization trials, compared to a full-factorial experiment, that may be required to configure the algorithm in discrete and limited parameters steps.

<p align="center">
  <img src="https://github.com/trejkev/slam_auto_calibrator/assets/18760154/0f1bb290-76bc-4294-99a4-3105c1c39320" width="800" />
</p>

The tool uses DEAP, a Python library implementing a simple genetic algorithm, to try to converge to the set of params that maximizes an output function result. 

## Dependencies
1. ROS Melodic (ROS1)
2. Python 2.7
4. Gazebo
5. Rviz
6. deap 1.4.1

## Steps to use the node:
1. Into _slam_auto_calibrator.launch_, set the variables needed to run the optimization or validation algorithm, most of them are mandatory.
2. Into _single_robot_in_world.launch_, set the environment with the robot to be used.
3. Into the _slam_launcher.launch_, set the variables needed to run the SLAM algorithms desired, and the navigation algorithm to be used.
4. Make sure nav node points.py has the correct points to target, and also points to your robot, according to the Coordinates_Dictionary variable into _slam_launcher.launch_ file.
5. Start _roscore_ in a shell, and then, run the node in another shell by using the command _roslaunch slam_auto_calibrator slam_auto_calibrator.launch_.

## SLAM Auto Calibrator Parameters description
Into slam_auto_calibrator.launch reside the most important parameters to make the automated optimization algorithm work, those are described below.

### General Arguments
1. SLAM_Name: This is a parameter used to name everything related to the present run, either validation or optimization. It includes map naming, output into the logs, and so on.
2. Robots_Quantity: This parameter is needed to let the algorithm know how many robots are in the arena, and is used to correctly grab the results from each run to compute the results.
3. Robots_Launch_Name: This parameter lets the algorithm know what launch file to call, to power up the arena with the robots.
4. Self_Package_Name: This parameter contains the package path, so that it can quickly identify where the Maps, src, and other relevants are.
5. SLAM_Launch_Name: This parameter brings the launch filename containing the SLAM algorithm for each of the robots, and also starts the automated navigator node for each of them.
6. APE_Topic_Name: This parameter gives the absolute pose error topic name, where the pose error of each of the robots will be published.
7. Robots_Pronoun: This algorithm identifies each of the robot nodes with a pronoun, this variable lets the user set this pronoun.
8. Ground_Truth_Filename: This parameter contains the filename of the ground truth image, which MUST be located into Maps directory.

### Test Approach Arguments
1. Run_Type: This parameter lets the user decide between performing Optimization or Validation (case insensitive).
2. Validation_Trials_Qty: If performing validation this parameter is a must, and shall tell the number of validation trials to perform.
3. Training_Cycles: If performing optimization this parameter is a must, and shall tell the number of cycles to train the algorithm in the search for the best set of parameters.

### Paths Arguments
1. This_Node_src_Path: This variable tells the algorithm where the package is located from the root directory.
2. Maps_Path: This parameter lets the user define where to store the maps, both, the generated by the SLAM algorithm, and the ground truth.
3. Params_File_Path: This parameter tells where the SLAM algorithm parameters are stored, and it shall point to the corresponding yaml file.

## Setting Up a Different SLAM Algorithm

To set a different SLAM algorithm, it is required to modify two different files, these are mentioned below.

### slam_auto_calibrator.launch

This file contains two important variables to consider:
1. **SLAM_Name**: This variable is used to give a name to the output maps generated by the robots. As is, this change is not mandatory, but is required to keep the standard and avoid confusion while using this node.
2. **Params_File_Path**: This variable is mandatory, it sets the path to the yaml file that contains the parameters of the given SLAM algorithm, and it is used to update the parameter values for the given SLAM algorithm. To get some clues about how to set this file, go to **Parameters File Format**.

### slam_launcher.launch

This file holds the general configuration of each of the robots in the arena, therefore, here we define the specific SLAM algorithm to be used by each of the robots, if you want to change the SLAM algorithm to be run by your robot(s), here is where you must do so, look for the specific group of each of the robots, and update the package to be used for localization and mapping.

## Parameters File: Parameter Format

Yaml files are used to store parameters modification, when the user wants to set a parameter to a different value than its default value. Doing so is quite simple, the user just has to type in the parameter, followed by a colon sign, and next the new value.

However, to be able to use an optimization algorithm, there was a need to tell what the variable type is, and what its maximum and minimum desired values are, so that it was possible to set a search space, tailored by the user. The way this was implemented  was by following this standard: _{variable}: {initial value} #{var type (only int, float, and bool are allowed)} #min={min value} #max={max value}_. See the example below.

<p align="center">
  <img src="https://github.com/trejkev/slam_auto_calibrator/assets/18760154/f5cd020d-0f33-4b93-8fd3-ca91142c06bf" width="800" />
</p>

## Pseudocode of the Artifact

In general, the code follows the pseudocode below, which is a very simplified version of what it does.

    # SLAM Calibration Optimization & Validation - Pseudocode
    
    FUNCTION run_cycle()
        call cycle_base_launching() -> Simulated environment with robot(s) using SLAM
    
        LOG "Starting lap" currentCycle
    
        WHILE trial_ongoing THEN
            IF slam_unresponsive THEN
                LOG "SLAM failed connection, configuration makes it crash"
                call record_errors(with_error = TRUE) -> Record map errors as humongous values
                RETURN very_large_map_error_value
            ENDIF
        ENDWHILE
    
        LOG "Completed lap" currentCycle
    
        LOG "Generating map for cycle" currentCycle
        call generate_map()
    
        LOG "Computing map metric for cycle" currentCycle
        call compute_map_metric()
    
        LOG "Recording errors for cycle" currentCycle
        call record_errors()
    
        RETURN current_map_error
    END FUNCTION
    
    ---
    
    FUNCTION target_function(individual)
        FOR EACH param IN parameter_keys DO
            value = individual[index_of(param)]
            CLAMP value within param_bounds
            CONVERT value TO param_type (int, float, bool)
            UPDATE parameter_dictionary[param] WITH value
        END FOR
    
        LOG "Current run params:" parameters
        call set_parameters_on_yaml()
    
        RETURN run_cycle()
    END FUNCTION
    
    ---
    
    FUNCTION mutate_individual(individual, mutation_probability)
        FOR EACH param IN parameter_keys DO
            IF param_type == float THEN
                individual[param_index] += random_gauss(0, 0.1)
                CLAMP individual[param_index] within bounds
            ELSE IF param_type == int THEN
                IF random() < mutation_probability THEN
                    individual[param_index] += random_int(-1, 1)
                    CLAMP individual[param_index] within bounds
                ENDIF
            ELSE IF param_type == bool THEN
                IF random() < mutation_probability THEN
                    individual[param_index] = NOT individual[param_index]
                ENDIF
            ENDIF
        END FOR
    
        RETURN individual
    END FUNCTION
    
    ---
    
    FUNCTION optimize_parameters()
        CREATE GA types: FitnessMin, Individual
    
        LOAD parameters from YAML
    
        INITIALIZE toolbox
    
        REGISTER GA attributes based on parameters
    
        REGISTER individual and population initialization
    
        REGISTER evaluate = target_function
        REGISTER mate     = blend_crossover(alpha=0.5)
        REGISTER mutate   = mutate_individual(indpb=0.2)
        REGISTER select   = tournament_selection(size=3)
    
        INITIALIZE population with size from launchParams
    
        SET crossover_prob = 0.5
        SET mutation_prob  = 0.2
        SET generations    = launchParams["Generations_Qty"]
    
        SET statistics collectors (avg, std, min, max)
        SET hall_of_fame size = 1
    
        RUN eaSimple GA with the above settings
    
        best_individual = hall_of_fame[0]
        LOG best_individual and fitness
    
        LOG "Validating best parameters for 30 trials"
        FOR i = 1 TO 30 DO
            CALL target_function(best_individual)
        END FOR
    END FUNCTION
    
    ---
    
    FUNCTION validate_parameters(trial_count)
        LOG "Running validation for" trial_count "trials"
        LOAD parameters from YAML
        FOR i = 1 TO trial_count DO
            CALL run_cycle()
        END FOR
    END FUNCTION
    
    ---
    
    MAIN
        CREATE calibrator_instance
    
        GET run_type = ROS_PARAM("/RunType")
    
        IF run_type == "optimization" THEN
            LOG "RUNNING OPTIMIZATION"
            calibrator_instance.optimize_parameters()
        ELSE IF run_type == "validation" THEN
            LOG "RUNNING VALIDATION"
            GET validation_trials = ROS_PARAM("/ValidationTrialsQty")
            calibrator_instance.validate_parameters(validation_trials)
        ENDIF
    
        calibrator_instance.kill_all_nodes()
        TRY
            rosnode.kill_nodes(['slam_auto_calibrator'])
        CATCH exception
            LOG "Failed to kill node slam_auto_calibrator:", exception
    END MAIN


